[{"authors":null,"categories":null,"content":"I am a Software Engineer at Microsoft, where I work on the Azure SDK for JavaScript. I focus on developer experience, designing and implementing idiomatic and intuitive APIs for REST services in TypeScript. Before Microsoft, I was a PhD student at the University of Colorado Boulder, where I studied Computer Science Education. I\u0026rsquo;m a Linux enthusiast, and I enjoy working and playing with Linux containers and related technology such as Kubernetes/OpenShift.\nI\u0026rsquo;m building a hobbyist programming language (who isn\u0026rsquo;t these days?). The goal of Serendipity is to identify elemental constructions in computing and to design a language with an elegant and expressive syntax and type system to teach those structures. You can find any writing about that project, my other projects, and of course any rants on the blog.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1609463523,"objectID":"8ac9a1b188fa0bea08b643aecc98734b","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"I am a Software Engineer at Microsoft, where I work on the Azure SDK for JavaScript. I focus on developer experience, designing and implementing idiomatic and intuitive APIs for REST services in TypeScript.","tags":null,"title":"Will Temple","type":"authors"},{"authors":null,"categories":null,"content":"Serendipity is a new prototype programming environment for desktops and the web. Currently, it is in the proof-of-concept stage. It is powered by a tiny core language that is:\n purely-functional. dynamically-typed. lazy-evaluated.  The design and overall philosophy of Serendipity is inspired by the many wonderful programming languages that I have had the pleasure to use, primarily Racket, JavaScript, Rust, and Clojure. My greatest aspiration for it is that students and experienced programmers alike might use it to discover powerful and fundamental ideas in Computer Science through exploring an interactive programming environment.\nI designed Serendipity with the intent of developing several front-ends. If I succeed, then it should be easy to develop completely new front-ends for serendipity that use a variety of editing modalities. Currently, there are two front-ends: the basic blocks-based editor featured in the screenshot above and a Lisp-like front-end that I use for debugging. The blocks editor uses React.js and MobX state management. The UI is powered by ordinary SVG.\nCurrently, Serendipity is implemented entirely in TypeScript, though I intend to rewrite some or all of it in Rust (or hopefully in a Serendipity front-end) as needed.\nCompared to Other Block Programming Engines Serendipity\u0026rsquo;s block editor was borne out of frustrations with existing block programming toolkits, in particular Google\u0026rsquo;s Blockly. The fundamental problem with Blockly and its many forks is that it treats blocks as merely a representation of text. When a blockly program is compiled, it is transformed into text, and then the text is processed using conventional compilers/runtimes. While this has some advantages, it introduces a lot of complexity in the process of returning useful diagnostic information to the user in the block workspace. It also means that, in some cases, text programs cannot be represented by blocks (try writing a higher-order program in a Blockly-based language!).\nSerendipity\u0026rsquo;s editor instead views blocks as a direct representation of the program\u0026rsquo;s abstract syntax tree. Serendipity\u0026rsquo;s editor is therefore a structure editor, and when a user manipulates the blocks, they manipulate the abstract syntax tree directly. This means that there is no parser in the web editor, as the principal data structure of the program is the syntax tree, rather than a text file as would be the case with conventional text-based or Blockly-based programming.\nCompiler Serendipity\u0026rsquo;s compiler, though simple, contains some unusual transformations that the compiler-interested may find intriguing. While the core runtime language is purely-functional, the front-end languages allow for procedural programming. For example, consider the following iterative program (using the Lisp front-end):\n; A sequence of integers starting at n (define (seq n) (cons n (seq (+ n 1)))) (main [proc (for-in [i (seq 0)] (do [proc (if (\u0026gt;= i 10) (break)) (print i) ])) ])  In this front-end, proc is a fundamental constructor for a procedural block of code. While this construction appears similar to begin in Scheme (by design), its implementation is much different. When this program is compiled, Serendipity will apply a series of transformation that reduce procedural programs into functional programs using a continuation-passing style with an explicit \u0026ldquo;world\u0026rdquo; argument.\nIn the language of Serendipity\u0026rsquo;s runtime, the main program above is reduced to a pure functional computation (formatted and annotated for \u0026ldquo;readability\u0026rdquo;):\n;; Main entry point, with some shim code for bootstrapping CPS ;; __k defines ((λ__k.λ__w.( ;; The fundamental looping constructor provides a continuation for breaking λ__brk.( ;; Iteration recursively binds a single iteration as a continuation until ;; the loop is broken, either by an explicit `(break)` or by the iterator ;; returning nil. (`seq` below is bound in the environment.) λ__loop.((__loop __w) (seq 0)) ( ;; Fixed-point combinator allows for recursive binding of the loop ;; body λf.(λx.(x x) λx.(f (x x))) λ__loop.λ__w.λ__iter.( ;; Test for iterator termination (== __iter ∅) ;; If the iterator terminated (produced nil), we call the break ;; continuation ? (__brk __w) ;; Otherwise, run the iterator body, which starts with an (if) construction : (λi.(λ__w.((λ__k.λ__w.(λ__next.( ;; Do you recognize this? It's just the test for (\u0026gt;= i 10) that appeared ;; in the base program. Pure expressions are reproduced verbatim. (\u0026gt;= i 10) ;; The explicit call to break is rendered as an immediate call to the ;; breaking continuation ? (__brk __w) ;; Otherwise, evaluate the __next continuation (specifies the continuation ;; that handles the result of the entire (if) construction) : (__next __w)) ;; The next continuation calls the `print` core builtin function. ;; Eventually this will be modeled as a monadic structure. For now it ;; simply returns the world as-is λ__w.( (λ__k.λ__w.((__core.print i) ((λ__k.λ__w.(__k __w) __k) __w)) __k) __w)) ;; Evaluate __iter[1] (next value in the iterator) and loop over it ;; by finally cascading the world arguments and continuations λ__w.(λ__w.((__loop __w) __iter[1]) __w)) __w) __w) __iter[0]) ))) ;; This is bootstrapping code, though you can see that the \u0026quot;world\u0026quot; is ;; initialized to nil in the final argument (keep in mind that this is ;; reversed, so nil is actually the *first* argument evaluated and passed ;; into this CPS-call expression). λ__w.((λ__k.λ__w.(__k __w) __k) __w)) λ__w.__w) ∅)  The choice to use this extremely simple Church-ish language, though not very readable (that said, I don\u0026rsquo;t think it is that much worse than assembly language), enables all of the theoretical static analysis and optimization that is only useful in pure-functional programs (to summarize: it is very easy to statically analyze a pure-functional program). I believe that this pattern of continuation-passing combined with dead-code and tail-call elimination along with the essence of laziness (you\u0026rsquo;ll find that all of the function calls above are tail recursive except for the infinite, where we are assisted by laziness) provides a very promising substrate for building Serendipity far into the future.\nWhat\u0026rsquo;s Next? In addition to adding enough features to the editor to take Serendipity from a proof-of-concept stage to a usable Alpha stage (currently, you can\u0026rsquo;t save a program and have to use the debugging console to spawn new blocks), I am developing a non-Lisp-like textual representation of Serendipity programs that will have two front-ends: a text parser and a text-like structure editor (similar to the incredibly powerful editor of the Hazel project) as a counterpart to the blocks-based structure editor.\nEventually, I will rewrite most of the block rendering code to use either HTML canvas or a GPU subsystem (WebGL or WebGPU), as I am reaching the limits of what I can easily accomplish within React and SVG due to uncontrollable accumulations of SVG jank.\nBeyond the editor, the next monster problem to solve is to define and implement a type system. I have become completely enamored with TypeScript\u0026rsquo;s approach to type-checking JavaScript: interface-driven optional typing. That said, TypeScript isn\u0026rsquo;t perfect, and there are mistakes that were made along its development into the beloved language that it is today, and I now have the benefit of being able to learn from those mistakes. I am attracted to the idea of truly optional typing, in which a user might provide a type (but doesn\u0026rsquo;t have to), and we can check it statically, with no runtime cost, if a type is provided.\nHowever, implementing a type checker isn\u0026rsquo;t the reason it\u0026rsquo;s a monster problem. Writing some software for basic optional typing is simple enough. The monstrosity comes from trying to figure out how to represent optional type annotations in a blocks-based programming language. None of the block environments that I\u0026rsquo;m familiar with do this very satisfactorially (or at all), so if you are aware of any, send me an email or leave a comment below!\n","date":1606780800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609463523,"objectID":"6cf8f585723991f02e6ed8a8b0069d6e","permalink":"https://www.wtemple.info/project/serendipity/","publishdate":"2020-12-01T00:00:00Z","relpermalink":"/project/serendipity/","section":"project","summary":"A programming language and editor for learning and exploration.","tags":["Education","Programming Languages","Blocks"],"title":"Serendipity","type":"project"},{"authors":null,"categories":null,"content":"PeerReviewWeb is a platform that supports the integration of Peer Reviews into coursework. During or after submitting work for an assignment in a course, students will review and comment on each others' work.\nIt supports multiple courses, configurable instruction staff and student rosters, multiple assignments and multi-stage assignments, with configurable assignment group settings, and configurable review parameters including dynamic review forms.\n","date":1577836800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609463523,"objectID":"5a3162a4d453a7a6250b7afa7b5ff33c","permalink":"https://www.wtemple.info/project/prweb/","publishdate":"2020-01-01T00:00:00Z","relpermalink":"/project/prweb/","section":"project","summary":"C#/ASP.NET web application to facilitate pedagogical peer reviews.","tags":["Education","Peer Review"],"title":"PeerReviewWeb","type":"project"},{"authors":["Will Temple"],"categories":null,"content":"In February 2018, I started working seriously on the BlockyTalky 3 project, a web-based physical computing editor for linux systems. We initially chose to target the Raspberry Pi, and we chose to use Microsoft MakeCode as the base of the web IDE. MakeCode is a relatively mature blocks-based code editor (one of the official platforms of the BBC micro:bit), and, for a while, it made a lot of sense to build off of it instead of creating a new editor from scratch.\nHowever, MakeCode was designed to compile users’ Static TypeScript code to native ARM machine code assemblies to be flashed to the device over USB or a programming interface. In our case, the Raspberry Pi is a fully-functional Linux device, so we are able to run whatever Linux software we can manage to compile for it as long as it is within the Pi’s ability to run it. So, we decided to simply transmit the user’s code from the web editor to the Raspberry Pi for execution. This approach had a few major benefits:\n Running the code in a full Linux environment would allow us to rapidly develop integrations with the rich ecosystem of Linux and Node software. We wouldn’t have to build complex C/C++ libraries to leverage the hardware of the Raspberry Pi. We would be able to use the Pi itself to apply transformations to user code and archive it for research purposes.  It took a few months of planning, trial, and error to nail down exactly how this program lifecycle would work. We finally settled on a procedure with three major steps. This is how a user’s program in the browser eventually executes on the BlockyTalky Unit (Raspberry Pi).\n BlockyTalky Document Flow   Editor When the user is writing the program in the editor within their browser, it continuously runs automated analysis (such as typechecking) against the user’s code. In our derivative of MakeCode, the in-browser virtual machine is disabled, but the compiler still runs and generates diagnostics. When the user clicks the button labeled “Compile and Run” in the bottom left (pictured below), the editor gathers the entire user code bundle in source format (see the next section), serializes it to JSON, and transmits it to the BTU (the Pi). It uses an HTTP POST message to the endpoint at /api/save using the same server and port that originally served the editor itself. Conceptually, this is the simplest component of BlockyTalky 3. In actual practice, it is the hardest component to modify and extend.\n BlockyTalky 3 Editor Interface   Anatomy of a User Bundle User code files are organized into a virtual file-system within the web editor. In each bundle, there is:\n One pxt.json file that encodes information about the files in the bundle and their dependencies One main.ts file that contains the main TypeScript code, generated from the blocks workspace. This is the entry-point of the program. Optionally, one or more extension TypeScript (.ts) files. Exported functions and classes in this file are available in main.ts without needing to be imported.  On the wire between the editor and the orchestrator, these files are serialized together as a single JSON-encoded object. That object has filenames as keys and file contents as values.\nThe orchestrator manages executing child processes on the BTU. Conceptually, this is probably the most complicated part of the process, though it involves the least actual code. When a new user code bundle is POST’d to /api/save, the orchestrator attempts to decode it, and it then transforms each TypeScript file in the user’s code (non-TypeScript resources in the user code are not currently supported) according to certain rules that ensure a standard TypeScript compiler will be able to resolve dependecies which are abstracted away by the novice-friendly PXT editor. Those rules are (see this file on github):\n For BOTH main.ts and all extension files: the core library is always inserted first, and the loops and console libraries are always inserted next, as all packages implicitly import them, so each file begins with:  import * as _core from '/path/to/pxexec/lib/core-exec'; import * as loops from '/path/to/pxexec/lib/loops'; import * as console from '/path/to/pxexec/lib/console';    For BOTH main.ts and all extension files: Any packages marked as dependencies in pxt.json (from the user bundle) are imported in order in the same manner as the loops library. For example, projects import gpio by default (though they can unconfingure that dependency), so most projects will have a line import * as gpio from \u0026lsquo;/path/to/pxexec/lib/gpio\u0026rsquo;.\n  For ONLY main.ts: Any extension files in the user bundle will be imported, and we abuse prototypical inheritance to “merge” the extensions with their parent library object. In essence, we make it so that any access to the extension object will then fall back to the parent library object by setting it as the extension’s prototype, and then we replace the parent object with the extension object. This is a bit complicated to explain without getting into the meat of prototypical inheritance, but an example: if dmx.ts exists in the user bundle, the orchestrator will generate this code:\n  import * as dmxEX from './dmx'; Object.setPrototypeOf(dmxEX, dmx); dmx = dmxEX;   For ONLY main.ts: The original text of main.ts is put into a wrapper function that is passed to core.main, which defines the operating semantics of the runtime environment and performs necessary setup. So, the user’s code is transformed into:  _core.main(() =\u0026gt; { // user's code here });   For ONLY main.ts: there is a bug with WebRTC in Node which causes it to fail to import in some contexts (including within fibers). In order to avoid this bug, we manually import WebRTC and store it in a specified location in the core library. The networking module later reads this location and uses it when initializing the signaling system. To insert the module, we add the following line:  _core.hacks.wrtc = require('dss/client/node_modules/wrtc');  After transformation, the code is compiled using a thin typescript compiler that does not perform typechecking or any other kind of analysis. It just performs TypeScript-to-ES6 transformation (we do this to avoid having to load the entire runtime into the compiler for every step, which takes 5-6 seconds on even basic programs). The compiler outputs the compiled ES6 files to a temporary folder in /tmp.\nFinally, the executor (see pxexec-orchestrator/node_executor.ts) spawns a node child process to run the code. If a child process already exists from a previous lifecycle iteration, it is killed first. If all of the above steps succeed, then HTTP 200 is returned to the editor (so that it can show that nifty toast notification informing the user that the new program is running), otherwise, HTTP 500 is returned and an error message is displayed.\nRuntime At last, the program is running. The behavior of the runtime is to, first, resolve all imports and run the body of all of the imported library functions. Those library bodies are where packages can configure initialization requirements and teardown functions. The core library will run module initialization in a predictable way. The import of core itself configures exit handlers, so that the process can return some information to the orchestrator when it exits (such as the status code, or an exception trace). Finally, the node process encounters the _core.main(() =\u0026gt; { ... }); from earlier in our main.js file.\n_core.main spawns a fiber for the user code body. Fibers are a loose concurrency model that allow us to neatly abstract over operating system threads and to avoid unintentionally blocking the Node event loop, even though we are running synchronous code that may contain diverging constructs such as while (1) {}. Most importantly, they allow Node to interrupt the user’s synchronous code to service events. From this point, the user’s code executes apparently synchronously as written, and library service routines will detach all user-code handlers into their own fibers.\nThe program will terminate normally when the node event loop has no more configured awaiters (i.e. all fibers have terminated, all timers have expired, and all event handlers are unconfigured). Some types of programs, by their nature, will never terminate, due to having an unlimited wait time for an event (such as “when I receive” blocks).\nConclusion I hope this has been an interesting and instructive (if overly technical) look into some of the work that I’ve been up to for the past couple of years. While I am no longer working on the BlockyTalky 3 project, I have begun developing my own runtime and block-editing framework, Serendipity, which I hope will solve some of the more difficult design challenges discussed above. I view the Serendipity project in many ways as a spiritual successor to my involvement in the BlockyTalky 3 work, and I hope that anyone who is interested will continue to follow my progress on that project.\n","date":1560384000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609463523,"objectID":"b868be04c649482a0e030e6f293aa499","permalink":"https://www.wtemple.info/blog/lifecycle-bt3-program/","publishdate":"2019-06-13T00:00:00Z","relpermalink":"/blog/lifecycle-bt3-program/","section":"blog","summary":"Getting to know the experimental BlockyTalky 3 runtime, the lifecycle of a user's program, and how the source code interacts with the Raspberry Pi hardware.","tags":["Education","Software"],"title":"Lifecycle of a BlockyTalky 3 Program","type":"blog"}]