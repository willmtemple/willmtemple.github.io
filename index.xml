<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>wtemple.info</title>
    <link>https://www.wtemple.info/</link>
      <atom:link href="https://www.wtemple.info/index.xml" rel="self" type="application/rss+xml" />
    <description>wtemple.info</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© William Temple 2020</copyright><lastBuildDate>Tue, 01 Dec 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://www.wtemple.info/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>wtemple.info</title>
      <link>https://www.wtemple.info/</link>
    </image>
    
    <item>
      <title>Serendipity</title>
      <link>https://www.wtemple.info/project/serendipity/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://www.wtemple.info/project/serendipity/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Serendipity&lt;/strong&gt; is a new prototype programming environment for desktops and the
web. Currently, it is in the proof-of-concept stage. It is powered by a tiny
core language that is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;purely-functional.&lt;/li&gt;
&lt;li&gt;dynamically-typed.&lt;/li&gt;
&lt;li&gt;lazy-evaluated.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The design and overall philosophy of Serendipity is inspired by the many
wonderful programming languages that I have had the pleasure to use, primarily
&lt;a href=&#34;https://racket-lang.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Racket&lt;/a&gt;, JavaScript, Rust, and Clojure. My greatest aspiration for it
is that students and experienced programmers alike might use it to discover
powerful and fundamental ideas in Computer Science through exploring an
interactive programming environment.&lt;/p&gt;
&lt;p&gt;I designed Serendipity with the intent of developing several front-ends. If I
succeed, then it should be easy to develop completely new front-ends for
serendipity that use a variety of editing modalities. Currently, there are two
front-ends: the basic blocks-based editor featured in the screenshot above and
a Lisp-like front-end that I use for debugging. The blocks editor uses React.js
and MobX state management. The UI is powered by ordinary SVG.&lt;/p&gt;
&lt;p&gt;Currently, Serendipity is implemented entirely in TypeScript, though I intend
to rewrite some or all of it in Rust (or hopefully in a Serendipity front-end)
as needed.&lt;/p&gt;
&lt;h2 id=&#34;compared-to-other-block-programming-engines&#34;&gt;Compared to Other Block Programming Engines&lt;/h2&gt;
&lt;p&gt;Serendipity&amp;rsquo;s block editor was borne out of frustrations with existing block
programming toolkits, in particular Google&amp;rsquo;s &lt;a href=&#34;https://developers.google.com/blockly/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Blockly&lt;/a&gt;. The
fundamental problem with Blockly and its many forks is that it treats blocks as
merely a representation of text. When a blockly program is compiled, it is
transformed into text, and then the text is processed using conventional
compilers/runtimes. While this has some advantages, it introduces a lot of
complexity in the process of returning useful diagnostic information to the
user in the block workspace. It also means that, in some cases, text programs
cannot be represented by blocks (try writing a higher-order program in a
Blockly-based language!).&lt;/p&gt;
&lt;p&gt;Serendipity&amp;rsquo;s editor instead views blocks as a direct representation of the
program&amp;rsquo;s &lt;em&gt;abstract syntax tree&lt;/em&gt;. Serendipity&amp;rsquo;s editor is therefore a
&lt;em&gt;structure editor&lt;/em&gt;, and when a user manipulates the blocks, they manipulate the
abstract syntax tree directly. This means that there is no parser in the web
editor, as the principal data structure of the program is the syntax tree,
rather than a text file as would be the case with conventional text-based or
Blockly-based programming.&lt;/p&gt;
&lt;h2 id=&#34;compiler&#34;&gt;Compiler&lt;/h2&gt;
&lt;p&gt;Serendipity&amp;rsquo;s compiler, though simple, contains some unusual transformations
that the compiler-interested may find intriguing. While the core runtime
language is purely-functional, the front-end languages allow for procedural
programming. For example, consider the following iterative program (using the
Lisp front-end):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;; A sequence of integers starting at n
(define (seq n) (cons n (seq (+ n 1))))

(main [proc
  (for-in [i (seq 0)] (do [proc
    (if (&amp;gt;= i 10) (break))
    (print i)
  ]))
])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this front-end, &lt;code&gt;proc&lt;/code&gt; is a fundamental constructor for a procedural block
of code. While this construction appears similar to &lt;code&gt;begin&lt;/code&gt; in Scheme (by
design), its implementation is much different. When this program is compiled,
Serendipity will apply a series of transformation that reduce procedural
programs into functional programs using a continuation-passing style with an
explicit &amp;ldquo;world&amp;rdquo; argument.&lt;/p&gt;
&lt;p&gt;In the language of Serendipity&amp;rsquo;s runtime, the &lt;code&gt;main&lt;/code&gt; program above is reduced
to a pure functional computation (formatted and annotated for &amp;ldquo;readability&amp;rdquo;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;;; Main entry point, with some shim code for bootstrapping CPS
;; __k defines 
((λ__k.λ__w.(
 ;; The fundamental looping constructor provides a continuation for breaking
 λ__brk.(
  ;; Iteration recursively binds a single iteration as a continuation until
  ;; the loop is broken, either by an explicit `(break)` or by the iterator
  ;; returning nil. (`seq` below is bound in the environment.)
  λ__loop.((__loop __w) (seq 0)) (
   ;; Fixed-point combinator allows for recursive binding of the loop
   ;; body
   λf.(λx.(x x) λx.(f (x x))) λ__loop.λ__w.λ__iter.(
    ;; Test for iterator termination
    (== __iter ∅)
    ;; If the iterator terminated (produced nil), we call the break
    ;; continuation
    ? (__brk __w)
    ;; Otherwise, run the iterator body, which starts with an (if) construction
    : (λi.(λ__w.((λ__k.λ__w.(λ__next.(
     ;; Do you recognize this? It&#39;s just the test for (&amp;gt;= i 10) that appeared
     ;; in the base program. Pure expressions are reproduced verbatim.
     (&amp;gt;= i 10)
     ;; The explicit call to break is rendered as an immediate call to the
     ;; breaking continuation 
     ? (__brk __w)
     ;; Otherwise, evaluate the __next continuation (specifies the continuation
     ;; that handles the result of the entire (if) construction)
     : (__next __w))
     ;; The next continuation calls the `print` core builtin function.
     ;; Eventually this will be modeled as a monadic structure. For now it
     ;; simply returns the world as-is
     λ__w.(
       (λ__k.λ__w.((__core.print i) ((λ__k.λ__w.(__k __w) __k) __w)) __k)
       __w))
     ;; Evaluate __iter[1] (next value in the iterator) and loop over it
     ;; by finally cascading the world arguments and continuations
     λ__w.(λ__w.((__loop __w) __iter[1]) __w)) __w) __w) __iter[0])
   )))
   ;; This is bootstrapping code, though you can see that the &amp;quot;world&amp;quot; is
   ;; initialized to nil in the final argument (keep in mind that this is
   ;; reversed, so nil is actually the *first* argument evaluated and passed
   ;; into this CPS-call expression).
   λ__w.((λ__k.λ__w.(__k __w) __k) __w)) λ__w.__w) ∅)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The choice to use this extremely simple Church-ish language, though not very
readable (that said, I don&amp;rsquo;t think it is that much worse than assembly
language), enables all of the theoretical static analysis and optimization that
is only useful in pure-functional programs (to summarize: it is very easy to
statically analyze a pure-functional program). I believe that this pattern of
continuation-passing combined with dead-code and tail-call elimination along
with the essence of laziness (you&amp;rsquo;ll find that &lt;em&gt;all&lt;/em&gt; of the function calls
above are tail recursive except for the infinite, where we are assisted by
laziness) provides a very promising substrate for building Serendipity far into
the future.&lt;/p&gt;
&lt;h2 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s Next?&lt;/h2&gt;
&lt;p&gt;In addition to adding enough features to the editor to take Serendipity from a
proof-of-concept stage to a usable Alpha stage (currently, you can&amp;rsquo;t save a
program and have to use the debugging console to spawn new blocks), I am
developing a non-Lisp-like textual representation of Serendipity programs that
will have two front-ends: a text parser and a text-like structure editor
(similar to the incredibly powerful editor of the &lt;a href=&#34;https://hazel.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hazel&lt;/a&gt; project) as a
counterpart to the blocks-based structure editor.&lt;/p&gt;
&lt;p&gt;Eventually, I will rewrite most of the block rendering code to use either HTML
&lt;code&gt;canvas&lt;/code&gt; or a GPU subsystem (WebGL or WebGPU), as I am reaching the limits of
what I can easily accomplish within React and SVG due to uncontrollable
accumulations of SVG jank.&lt;/p&gt;
&lt;p&gt;Beyond the editor, the next monster problem to solve is to define and implement
a type system. I have become completely enamored with TypeScript&amp;rsquo;s approach to
type-checking JavaScript: interface-driven optional typing. That said,
TypeScript isn&amp;rsquo;t perfect, and there are mistakes that were made along its
development into the beloved language that it is today, and I now have the
benefit of being able to learn from those mistakes. I am attracted to the idea
of truly optional typing, in which a user &lt;em&gt;might&lt;/em&gt; provide a type (but doesn&amp;rsquo;t
have to), and we can check it statically, with no runtime cost, if a type is
provided.&lt;/p&gt;
&lt;p&gt;However, implementing a type checker isn&amp;rsquo;t the reason it&amp;rsquo;s a monster problem.
Writing some software for basic optional typing is simple enough. The
monstrosity comes from trying to figure out how to represent optional type
annotations in a blocks-based programming language. None of the block
environments that I&amp;rsquo;m familiar with do this very satisfactorially (or at all),
so if you are aware of any, send me an email or leave a comment below!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PeerReviewWeb</title>
      <link>https://www.wtemple.info/project/prweb/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://www.wtemple.info/project/prweb/</guid>
      <description>&lt;p&gt;PeerReviewWeb is a platform that supports the integration of Peer Reviews into
coursework. During or after submitting work for an assignment in a course,
students will review and comment on each others&#39; work.&lt;/p&gt;
&lt;p&gt;It supports multiple courses, configurable instruction staff and student
rosters, multiple assignments and multi-stage assignments, with configurable
assignment group settings, and configurable review parameters including dynamic
review forms.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lifecycle of a BlockyTalky 3 Program</title>
      <link>https://www.wtemple.info/blog/lifecycle-bt3-program/</link>
      <pubDate>Thu, 13 Jun 2019 00:00:00 +0000</pubDate>
      <guid>https://www.wtemple.info/blog/lifecycle-bt3-program/</guid>
      <description>&lt;p&gt;In February 2018, I started working seriously on the &lt;a href=&#34;https://github.com/LaboratoryForPlayfulComputation/pxt-pi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BlockyTalky 3&lt;/a&gt;
project, a web-based physical computing editor for linux systems. We initially
chose to target the Raspberry Pi, and we chose to use &lt;a href=&#34;https://github.com/Microsoft/pxt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Microsoft
MakeCode&lt;/a&gt; as the base of the web IDE. MakeCode is a relatively mature
blocks-based code editor (one of the official platforms of the BBC micro:bit),
and, for a while, it made a lot of sense to build off of it instead of creating
a new editor from scratch.&lt;/p&gt;
&lt;p&gt;However, MakeCode was designed to compile users’ Static TypeScript code to
native ARM machine code assemblies to be flashed to the device over USB or a
programming interface. In our case, the Raspberry Pi is a fully-functional
Linux device, so we are able to run whatever Linux software we can manage to
compile for it as long as it is within the Pi’s ability to run it. So, we
decided to simply transmit the user’s code from the web editor to the Raspberry
Pi for execution. This approach had a few major benefits:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Running the code in a full Linux environment would allow us to rapidly
develop integrations with the rich ecosystem of Linux and Node software.&lt;/li&gt;
&lt;li&gt;We wouldn’t have to build complex C/C++ libraries to leverage the hardware
of the Raspberry Pi.&lt;/li&gt;
&lt;li&gt;We would be able to use the Pi itself to apply transformations to user code
and archive it for research purposes.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It took a few months of planning, trial, and error to nail down exactly how
this program lifecycle would work. We finally settled on a procedure with three
major steps. This is how a user’s program in the browser eventually executes on
the BlockyTalky Unit (Raspberry Pi).&lt;/p&gt;


















&lt;figure id=&#34;figure-blockytalky-document-flow&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;./featured.png&#34; data-caption=&#34;BlockyTalky Document Flow&#34;&gt;


  &lt;img src=&#34;./featured.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption data-pre=&#34;Figure&amp;nbsp;&#34; data-post=&#34;:&amp;nbsp;&#34; class=&#34;numbered&#34;&gt;
    BlockyTalky Document Flow
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h2 id=&#34;editor&#34;&gt;Editor&lt;/h2&gt;
&lt;p&gt;When the user is writing the program in the editor within their browser, it
continuously runs automated analysis (such as typechecking) against the user’s
code. In our derivative of MakeCode, the in-browser virtual machine is
disabled, but the compiler still runs and generates diagnostics. When the user
clicks the button labeled “Compile and Run” in the bottom left (pictured
below), the editor gathers the entire user code bundle in source format (see
the next section), serializes it to JSON, and transmits it to the BTU (the Pi).
It uses an HTTP POST message to the endpoint at /api/save using the same server
and port that originally served the editor itself. Conceptually, this is the
simplest component of BlockyTalky 3. In actual practice, it is the hardest
component to modify and extend.&lt;/p&gt;


















&lt;figure id=&#34;figure-blockytalky-3-editor-interface&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;./editor.png&#34; data-caption=&#34;BlockyTalky 3 Editor Interface&#34;&gt;


  &lt;img src=&#34;./editor.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption data-pre=&#34;Figure&amp;nbsp;&#34; data-post=&#34;:&amp;nbsp;&#34; class=&#34;numbered&#34;&gt;
    BlockyTalky 3 Editor Interface
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;anatomy-of-a-user-bundle&#34;&gt;Anatomy of a User Bundle&lt;/h3&gt;
&lt;p&gt;User code files are organized into a virtual file-system within the web editor.
In each bundle, there is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One pxt.json file that encodes information about the files in the bundle and
their dependencies&lt;/li&gt;
&lt;li&gt;One main.ts file that contains the main TypeScript code, generated from the
blocks workspace. This is the entry-point of the program.&lt;/li&gt;
&lt;li&gt;Optionally, one or more extension TypeScript (.ts) files. Exported functions
and classes in this file are available in main.ts without needing to be
imported.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;On the wire between the editor and the orchestrator, these files are serialized
together as a single JSON-encoded object. That object has filenames as keys and
file contents as values.&lt;/p&gt;
&lt;p&gt;The orchestrator manages executing child processes on the BTU. Conceptually,
this is probably the most complicated part of the process, though it involves
the least actual code. When a new user code bundle is POST’d to /api/save, the
orchestrator attempts to decode it, and it then transforms each TypeScript file
in the user’s code (non-TypeScript resources in the user code are not currently
supported) according to certain rules that ensure a standard TypeScript
compiler will be able to resolve dependecies which are abstracted away by the
novice-friendly PXT editor. Those rules are (see this file on github):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For BOTH main.ts and all extension files: the core library is always inserted
first, and the loops and console libraries are always inserted next, as all
packages implicitly import them, so each file begins with:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import * as _core from &#39;/path/to/pxexec/lib/core-exec&#39;;
import * as loops from &#39;/path/to/pxexec/lib/loops&#39;;
import * as console from &#39;/path/to/pxexec/lib/console&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;For BOTH main.ts and all extension files: Any packages marked as dependencies
in pxt.json (from the user bundle) are imported in order in the same manner
as the loops library. For example, projects import gpio by default (though
they can unconfingure that dependency), so most projects will have a line
import * as gpio from &amp;lsquo;/path/to/pxexec/lib/gpio&amp;rsquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For ONLY main.ts: Any extension files in the user bundle will be imported,
and we abuse prototypical inheritance to “merge” the extensions with their
parent library object. In essence, we make it so that any access to the
extension object will then fall back to the parent library object by setting
it as the extension’s prototype, and then we replace the parent object with
the extension object. This is a bit complicated to explain without getting
into the meat of prototypical inheritance, but an example: if dmx.ts exists
in the user bundle, the orchestrator will generate this code:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import * as dmxEX from &#39;./dmx&#39;;
Object.setPrototypeOf(dmxEX, dmx);
dmx = dmxEX;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;For ONLY main.ts: The original text of main.ts is put into a wrapper function
that is passed to core.main, which defines the operating semantics of the
runtime environment and performs necessary setup. So, the user’s code is
transformed into:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;_core.main(() =&amp;gt; {
  // user&#39;s code here
});
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;For ONLY &lt;code&gt;main.ts&lt;/code&gt;: there is a bug with WebRTC in Node which causes it to
fail to import in some contexts (including within fibers). In order to avoid
this bug, we manually import WebRTC and store it in a specified location in
the core library. The networking module later reads this location and uses it
when initializing the signaling system. To insert the module, we add the
following line:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;_core.hacks.wrtc = require(&#39;dss/client/node_modules/wrtc&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After transformation, the code is compiled using a thin typescript compiler
that does not perform typechecking or any other kind of analysis. It just
performs TypeScript-to-ES6 transformation (we do this to avoid having to load
the entire runtime into the compiler for every step, which takes 5-6 seconds on
even basic programs). The compiler outputs the compiled ES6 files to a
temporary folder in &lt;code&gt;/tmp&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Finally, the executor (see
&lt;a href=&#34;https://github.com/LaboratoryForPlayfulComputation/pxexec-orchestrator/blob/master/src/node_executor.ts&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pxexec-orchestrator/node_executor.ts&lt;/a&gt;)
spawns a node child process to run the code. If a child process already exists
from a previous lifecycle iteration, it is killed first. If all of the above
steps succeed, then HTTP 200 is returned to the editor (so that it can show
that nifty toast notification informing the user that the new program is
running), otherwise, HTTP 500 is returned and an error message is displayed.&lt;/p&gt;
&lt;h3 id=&#34;runtime&#34;&gt;Runtime&lt;/h3&gt;
&lt;p&gt;At last, the program is running. The behavior of the runtime is to, first,
resolve all imports and run the body of all of the imported library functions.
Those library bodies are where packages can configure initialization
requirements and teardown functions. The core library will run module
initialization in a predictable way. The import of core itself configures exit
handlers, so that the process can return some information to the orchestrator
when it exits (such as the status code, or an exception trace). Finally, the
node process encounters the &lt;code&gt;_core.main(() =&amp;gt; { ... });&lt;/code&gt; from earlier in our
&lt;code&gt;main.js&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;_core.main&lt;/code&gt; spawns a fiber for the user code body. Fibers are a loose
concurrency model that allow us to neatly abstract over operating system
threads and to avoid unintentionally blocking the Node event loop, even though
we are running synchronous code that may contain diverging constructs such as
&lt;code&gt;while (1) {}&lt;/code&gt;. Most importantly, they allow Node to interrupt the user’s
synchronous code to service events. From this point, the user’s code executes
apparently synchronously as written, and library service routines will detach
all user-code handlers into their own fibers.&lt;/p&gt;
&lt;p&gt;The program will terminate normally when the node event loop has no more
configured awaiters (i.e. all fibers have terminated, all timers have expired,
and all event handlers are unconfigured). Some types of programs, by their
nature, will never terminate, due to having an unlimited wait time for an event
(such as “when I receive” blocks).&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I hope this has been an interesting and instructive (if overly technical) look
into some of the work that I’ve been up to for the past couple of years. While
I am no longer working on the BlockyTalky 3 project, I have begun developing my
own runtime and block-editing framework, &lt;a href=&#34;https://www.wtemple.info/project/serendipity&#34;&gt;Serendipity&lt;/a&gt;,
which I hope will solve some of the more difficult design challenges discussed
above.  I view the Serendipity project in many ways as a spiritual successor to
my involvement in the BlockyTalky 3 work, and I hope that anyone who is
interested will continue to follow my progress on that project.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
