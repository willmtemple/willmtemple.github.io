<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="viewport"
          content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    
    <title>Will Temple - Lifecycle of a BlockyTalky 3 Program</title>
    <link href="/static/images/icon_n.png" rel="icon" type="image/png" />
    <link href="/stylesheets/site.css" rel="stylesheet" />
    <script src="/javascripts/site.js"></script>
    <!-- it's an article -->
    <link href="/stylesheets/highlight.css" rel="stylesheet" />
  </head>
  <body>
    <nav class="inverted">
    <div class="container">
        <h1><a href="/">Will Temple</a></h1>
        <button id="dropdown-expand"
            type="button"
            data-target="#navbar-dropdown"
            aria-label="Show navigation"
            aria-controls="navigationDropdown">
            
            <i class="fa fa-bars"></i>
        </button>
        <div id="navigationDropdown" class="links">
            <ul>
                    <li class="">
                        <a href="/resume">RÉSUMÉ</a>
                    </li>
                    <li class="">
                        <a href="/posts">POSTS</a>
                    </li>
                    <li class="">
                        <a href="/contact">CONTACT</a>
                    </li>
            </ul>
        </div>
    </div>
</nav>
    <div id="wrap">
      <div id="content">
          <div class="container">
                <article class="article container">
        <div class="meta">
            <header>
                <h1 class="title">Lifecycle of a BlockyTalky 3 Program</h1>
            </header>
            <address style="display:none;">William Temple</address>
            <div class="badges">
<a href="/posts/about/blockytalky-3/">                        <span class="badge badge-primary">BlockyTalky 3</span>
</a><a href="/posts/about/typescript/">                        <span class="badge badge-primary">TypeScript</span>
</a><a href="/posts/about/makecode/">                        <span class="badge badge-primary">MakeCode</span>
</a>            </div>
            <span class="info">
                &nbsp;<i class='far fa-calendar-alt'></i>&nbsp;
                Published:
                <time class="article-pub-date" pubdate datetime="2019-07-13">
                    July 13, 2019
                </time>
            </span>
        </div>
        <div class="text container">
            <hr />
            <p>In February 2018, I started working seriously on the <a href="https://github.com/LaboratoryForPlayfulComputation/pxt-pi">BlockyTalky
3</a> project, a
web-based physical computing editor for linux systems. We initially chose to
target the Raspberry Pi, and we chose to use
<a href="https://github.com/Microsoft/pxt">Microsoft MakeCode</a> as the base of the web
IDE. MakeCode is a relatively mature blocks-based code editor (one of the
official platforms of the <a href="https://makecode.microbit.org/beta">BBC micro:bit</a>),
and, for a while, it made a lot of sense to build off of it instead of creating
a new editor from scratch.</p><p></p><p>However, MakeCode was designed to compile users&rsquo; Static TypeScript code to
native ARM machine code assemblies to be flashed to the device over USB or a
programming interface.  In our case, the Raspberry Pi is a fully-functional
Linux device, so we are able to run whatever Linux software we can manage to
compile for it as long as it is within the Pi&rsquo;s ability to run it. So, we
decided to simply transmit the user&rsquo;s code from the web editor
to the Raspberry Pi for execution.  This approach had a few major benefits:</p>
<ol>
<li>Running the code in a full Linux environment would allow us to rapidly
develop integrations with the rich ecosystem of Linux and Node software</li>
<li>We wouldn&rsquo;t have to build complex C/C++ libraries to leverage the hardware
of the Raspberry Pi.</li>
<li>We would be able to use the Pi itself to apply transformations to user code
and archive it for research purposes</li>
</ol>
<p>It took a few months of planning, trial, and error to nail down exactly how
this program lifecycle would work.  We finally settled on a procedure with
three major steps. This is how a user&rsquo;s program in the browser eventually
executes on the BlockyTalky Unit (Raspberry Pi).</p><p><img src="/static/images/blog/bt3/lifecycle.png" alt="The BlockyTalky 3 Program Lifecycle Diagram" />
<label>Figure 1: BlockyTalky 3 document flow</label></p>      <a class="page-anchor" id="editor"></a>
      <a class="h2 anchor-link" href="#editor">
        <i class="fas fa-link"></i>
        <h2>Editor</h2>
      </a>
    <div class="gh-card">
      <div class="gh-meta">
        <i class="fas fa-eye"></i>
        2
        &nbsp;<i class="fas fa-star"></i>
        2
        &nbsp;<i class="fas fa-code-branch"></i>
        2
      </div>
      <i class="fab fa-github"></i>
      <a class="stretched-link" href="https://github.com/LaboratoryForPlayfulComputation/pxt-pi">
        <div class="gh-repoline">
        <span>
          LaboratoryForPlayfulComputation/
        </span><span>
          pxt-pi
        </span>
        </div>
      </a>
      <p>
        MakeCode editor targeted for the Raspberry Pi + Grove Pi
      </p>
    </div>
<p>When the user is writing the program in the editor within their browser, it
continuously runs automated analysis (such as typechecking) against the
user&rsquo;s code. In our derivative of MakeCode, the in-browser virtual machine is
disabled, but the compiler still runs and generates diagnostics. When the
user clicks the button labeled &ldquo;Compile and Run&rdquo; in the bottom left (pictured
below), the editor gathers the entire user code bundle in source format (see
the next section), serializes it to JSON, and transmits it to the BTU (the
Pi). It uses an HTTP POST message to the endpoint at <code>/api/save</code> using the
same server and port that originally served the editor itself. Conceptually,
this is the simplest component of BlockyTalky3. In actual practice, it is the
hardest component to modify and extend.</p><p><img src="/static/images/blog/bt3/ui.png" alt="The BlockyTalky 3 User Interaface" />
<label>Figure 2: BlockyTalky 3 editor interface</label></p>      <a class="page-anchor" id="anatomy-of-a-user-bundle"></a>
      <a class="h3 anchor-link" href="#anatomy-of-a-user-bundle">
        <i class="fas fa-link"></i>
        <h3>Anatomy of a User Bundle</h3>
      </a>
<p>User code files are organized into a virtual file-system within the web
editor. In each bundle, there is:</p>
<ul>
<li>One <code>pxt.json</code> file that encodes information about the files in the bundle
and their dependencies</li>
<li>One <code>main.ts</code> file that contains the main TypeScript code, generated from
the blocks workspace. This is the entry-point of the program.</li>
<li>Optionally, one or more extension TypeScript (<code>.ts</code>) files. Exported
functions and classes in this file are available in <code>main.ts</code> without needing to be imported.</li>
</ul>
<p>On the wire between the editor and the orchestrator, these files are
serialized together as a single JSON-encoded object. That object has
filenames as keys and file contents as values.</p>      <a class="page-anchor" id="orchestrator"></a>
      <a class="h2 anchor-link" href="#orchestrator">
        <i class="fas fa-link"></i>
        <h2>Orchestrator</h2>
      </a>
    <div class="gh-card">
      <div class="gh-meta">
        <i class="fas fa-eye"></i>
        1
        &nbsp;<i class="fas fa-star"></i>
        1
        &nbsp;<i class="fas fa-code-branch"></i>
        1
      </div>
      <i class="fab fa-github"></i>
      <a class="stretched-link" href="https://github.com/LaboratoryForPlayfulComputation/pxexec-orchestrator">
        <div class="gh-repoline">
        <span>
          LaboratoryForPlayfulComputation/
        </span><span>
          pxexec-orchestrator
        </span>
        </div>
      </a>
      <p>
        Runtime orchestration for PXT static-typescript execution hosts, such as Raspberry Pi w/pxt-pi
      </p>
    </div>
<p>The orchestrator manages executing child processes on the BTU. Conceptually,
this is probably the most complicated part of the process, though it involves
the least actual code. When a new user code bundle is POST&rsquo;d to <code>/api/save</code>,
the orchestrator attempts to decode it, and it then transforms each
TypeScript file in the user&rsquo;s code (non-TypeScript resources in the user code
are not currently supported) according to certain rules that ensure a
standard TypeScript compiler will be able to resolve dependencies which are
abstracted away by the novice-friendly PXT editor. Those rules are (see
<a href="https://github.com/LaboratoryForPlayfulComputation/pxexec-orchestrator/blob/master/src/compiler.ts">this file on github</a>):</p>
<ul>
<li>For BOTH <code>main.ts</code> and all extension files: the <code>core</code> library is always
inserted first, and the <code>loops</code> and <code>console</code> libraries are always inserted
next, as all packages implicitly import them, so each file begins with:</li>
</ul>
<div class="highlight"><pre class="highlight typescript"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">_core</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">/path/to/pxexec/lib/core-exec</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">loops</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">/path/to/pxexec/lib/loops</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">console</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">/path/to/pxexec/lib/console</span><span class="dl">'</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div>
<ul>
<li><p>For BOTH <code>main.ts</code> and all extension files: Any packages marked as
dependencies in <code>pxt.json</code> (from the user bundle) are imported in order in the
same manner as the loops library. For example, projects import <code>gpio</code> by
default (though they can unconfingure that dependency), so most projects will
have a line <code>import * as gpio from &#39;/path/to/pxexec/lib/gpio&#39;</code>.</p></li>
<li><p>For ONLY <code>main.ts</code>: Any extension files in the user bundle will be imported,
and we abuse prototypical inheritance to &ldquo;merge&rdquo; the extensions with their
parent library object. In essence, we make it so that any access to the
extension object will then fall back to the parent library object by setting
it as the extension&rsquo;s prototype, and then we replace the parent object with
the extension object. This is a bit complicated to explain without getting
into the meat of prototypical inheritance, but an example: if <code>dmx.ts</code> exists
in the user bundle, the orchestrator will generate this code:</p></li>
</ul>
<div class="highlight"><pre class="highlight typescript"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">dmxEX</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./dmx</span><span class="dl">'</span><span class="p">;</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">dmxEX</span><span class="p">,</span> <span class="nx">dmx</span><span class="p">);</span>
<span class="nx">dmx</span> <span class="o">=</span> <span class="nx">dmxEX</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div>
<ul>
<li>For ONLY <code>main.ts</code>: The original text of main.ts is put into a wrapper
function that is passed to core.main, which defines the operating semantics
of the runtime environment and performs necessary setup. So, the user&rsquo;s code
is transformed into:</li>
</ul>
<div class="highlight"><pre class="highlight typescript"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nx">_core</span><span class="p">.</span><span class="nx">main</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// user's code here</span>
<span class="p">});</span>
</pre></td></tr></tbody></table></code></pre></div>
<ul>
<li>For ONLY <code>main.ts</code>: there is a bug with WebRTC in Node which causes it to
fail to import in some contexts (including within fibers). In order to avoid
this bug, we manually import WebRTC and store it in a specified location in
the core library. The networking module later reads this location and uses it
when initializing the signaling system. To insert the module, we add the
following line:</li>
</ul>
<div class="highlight"><pre class="highlight typescript"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nx">_core</span><span class="p">.</span><span class="nx">hacks</span><span class="p">.</span><span class="nx">wrtc</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">dss/client/node_modules/wrtc</span><span class="dl">'</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div><p>After transformation, the code is compiled using a thin typescript compiler
that <em>does not</em> perform typechecking or any other kind of analysis. It just
performs TypeScript-&gt;ES6 transformation (we do this to avoid having to load
the entire runtime into the compiler for every step, which takes 5-6 seconds
on even basic programs). The compiler outputs the compiled ES6 files to a
temporary folder in /tmp.</p><p>Finally, the executor
(see
<a href="ihttps://github.com/LaboratoryForPlayfulComputation/pxexec-orchestrator/blob/master/src/node_executor.ts">pxexec-orchestrator:node_executor.ts</a>)
spawns a node child process to run the
code. If a child process already exists from a previous lifecycle iteration,
it is killed first. If <em>all</em> of the
above steps succeed, then HTTP 200 is returned to the editor (so that it can
show that nifty toast notification informing the user that the new program is
running), otherwise, HTTP 500 is returned and an error message is displayed.</p>      <a class="page-anchor" id="runtime"></a>
      <a class="h2 anchor-link" href="#runtime">
        <i class="fas fa-link"></i>
        <h2>Runtime</h2>
      </a>
    <div class="gh-card">
      <div class="gh-meta">
        <i class="fas fa-eye"></i>
        1
        &nbsp;<i class="fas fa-star"></i>
        1
        &nbsp;<i class="fas fa-code-branch"></i>
        1
      </div>
      <i class="fab fa-github"></i>
      <a class="stretched-link" href="https://github.com/LaboratoryForPlayfulComputation/pxexec-runtime">
        <div class="gh-repoline">
        <span>
          LaboratoryForPlayfulComputation/
        </span><span>
          pxexec-runtime
        </span>
        </div>
      </a>
      <p>
        Runtime support libraries for executing PXT code in Node
      </p>
    </div>
<p>At last, the program is running. The behavior of the runtime is to, first,
resolve all imports and run the body of all of the imported library
functions. Those library bodies are where packages can configure
initialization requirements and teardown functions. The core library will run
module initialization in a predictable way. The import of core itself
configures exit handlers, so that the process can return some information to the
orchestrator when it exits (such as the status code, or an exception trace).
Finally, the node process encounters the
<code>_core.main(() =&gt; { ... });</code> from earlier in our <code>main.js</code> file.</p><p><code>_core.main</code> spawns a fiber for the user code body. Fibers are a loose
concurrency model that allow us to neatly abstract over operating system
threads and to avoid unintentionally blocking the Node event loop, even
though we are running synchronous code that may contain diverging constructs
such as <code>while (1) {}</code>. Most importantly, they allow Node to interrupt the
user&rsquo;s synchronous code to service events. From this point, the user&rsquo;s code
executes <em>apparently synchronously</em> as written, and library service routines
will detach all user-code handlers into their own fibers.</p><p>The program will terminate normally when the node event loop has no more
configured awaiters (i.e. all fibers have terminated, all timers have
expired, and all event handlers are unconfigured). Some types of programs, by
their nature, will never terminate, due to having an unlimited wait time for
an event (such as &ldquo;when I receive&rdquo; blocks).</p>      <a class="page-anchor" id="conclusion"></a>
      <a class="h2 anchor-link" href="#conclusion">
        <i class="fas fa-link"></i>
        <h2>Conclusion</h2>
      </a>
<p>I hope this has been an interesting and instructive (if overly technical) look
into some of the work that I&rsquo;ve been up to for the past couple of years.  The
BlockyTalky project continues at the
<a href="https://playfulcomputation.group">Laboratory for Playful Computation</a>, and the
best place to get involved if you&rsquo;re interested is probably on the many Github
repositories (linked above). Someday soon, I hope to write a few words about
building and running the project from source, so that you can play around with
it and extend it yourselves.</p>
            <hr />
            <div class="end matter">
                <span>{</span>
                <span class="end">end</span>
                <span>}</span>
            </div>
            <div class="navigation">
                <div class="previous">
                </div>
                <div class="next">
                </div>
            </div>
        </div>
    </article>

          </div>
      </div>
    </div>
    <footer class="inverted">
    <p>
        &copy; 2019 William M. Temple II
        &middot;
        Powered by <a href="https://middlemanapp.com">Middleman</a>
    </p>
    <span style="font-size: 10pt; color: lightgrey; margin-top: 5px;">
        0e9219f
 - July 17, 2019
    </span>
</footer>
  </body>
</html>
